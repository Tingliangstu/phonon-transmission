Manual to calculate the phonon transmission function by Molecular Dynamics Simulation

To get the transmission function, we need the time dependent velocity and force constant matrix (the formulation of the transmission function can be found in PRB 90, 134312, 2014)

Step 1: calculate the velocities
Perform NEMD simulation. When the system reaches non-equilibrium steady state, we can collect the velocities.
The following is an example of lammps input file for this step:

atom_style      atomic
units           metal
dimension       3
boundary        p p p
processors      1 1 *

# ATOM DEFINITION
neighbor 2 bin
neigh_modify delay 10
neighbor        2.0 nsq
neigh_modify delay 0 every 1 check yes

variable CS  string  1900uc_1
variable posfile  string SiGe0.5_${CS}
variable restartfile string Si_bulk.quenched.restart
variable filename string SiGe0.5_${CS}

read_data  position_8-${posfile}

variable T equal 300
variable dT equal 60
variable TL equal $T+${dT}/2
variable TR equal $T-${dT}/2

# How many steps for initial linear temperature profile
variable steps_equil equal 1500000
# How many steps for reaching the steady state
variable steps_steady equal 2000000
# How many steps for the collection run
variable steps_simu equal 10000000

variable Tdamp equal 1.0 # In picoseconds

atom_modify sort 0 0.0
pair_style sw
pair_coeff * * /data/isilon/xiong/lammps/potential/SiGe.sw  Si Ge
timestep 0.0008 # Used in ?

# How large areas are fixed
variable Lfixed equal 8.0
# How large areas are thermalized
variable Lbath equal 171.0
variable Lhelp equal zhi-${Lfixed}
variable Lhelp2 equal zhi-${Lbath}

# How close to the middle of the structure the velocities are collected
variable dmid equal 3.0
variable zmid equal (zhi+zlo)/2.0
variable zmidlo equal ${zmid}-${dmid}
variable zmidhi equal ${zmid}+${dmid}


region 1 block INF INF INF INF INF ${Lfixed} units box
region 2 block INF INF INF INF ${Lhelp} INF units box
region 3 block INF INF INF INF INF ${Lbath}  units box
region 4 block INF INF INF INF ${Lhelp2} INF units box

region left block  INF INF INF INF ${zmidlo} ${zmid} units box
region right block INF INF INF INF ${zmid} ${zmidhi} units box

group fixedL region 1
group fixedR region 2
group fixed union fixedL fixedR

group hot region 3
group hot subtract hot fixedL
group cold region 4
group cold subtract cold fixedR

group interface_left region left
group interface_right region right
group interface union interface_left interface_right

group mobile subtract all fixed

thermo_style custom step temp etotal #cpu cpuremain
thermo_modify  flush  yes

velocity mobile create ${T} 23423424 dist gaussian mom yes
fix  1  fixed setforce 0.0 0.0 0.0

variable Tis atom ${TL}+z/zhi*(${TR}-${TL})

# FIXES
thermo 50000
fix NVE mobile nve
fix NVT mobile langevin v_Tis 1.0 ${Tdamp} 9348734 # zero yes

restart 500000 restart_${filename}*
run ${steps_equil}

write_restart ${filename}.equil.restart
# Write the restart data to file

unfix NVT


# Hot bath
fix HOT hot langevin ${TL} ${TL} ${Tdamp} 12223 tally yes # gjf yes
# Cold bath
fix COLD cold langevin ${TR} ${TR} ${Tdamp} 2276822 tally yes # gjf yes
compute KE all ke/atom

variable convert equal 2.0/3.0*1.602e-19/1.38e-23

variable Ti atom c_KE*${convert}
variable Ti2 atom v_Ti*v_Ti

fix input_hot hot ave/time 1 1 500 f_HOT ave one file ${filename}.aveinput_hot_start.dat
fix input_cold cold ave/time 1 1 500 f_COLD ave one file ${filename}.aveinput_cold_start.dat

fix ave_KE_start all ave/spatial 100 500 50000 z lower 5 v_Ti v_Ti2 units box ave one file ${filename}.Ti_start.dat title1 "Atomic temperatures"

# Wait for steady state
run ${steps_steady}
unfix ave_KE_start
unfix input_hot
unfix input_cold

reset_timestep 0
dump name1 all custom 1 dump_steady.${filename} id type x y z vx vy vz
run 1
undump name1

# quit

write_restart ${filename}.steadystate.restart
# quit
fix aveinput hot ave/time 1 1 100 f_HOT ave one file ${filename}.aveinput_hot.dat
fix aveinput_cold cold ave/time 1 1 100 f_COLD ave one file ${filename}.aveinput_cold.dat
fix ave_KE all ave/spatial 100 2 200 z lower 5 v_Ti v_Ti2 units box ave running file &
${filename}.Ti.dat overwrite title1 "Kinetic energies"

# undump equil_coords

# ALL COMPUTES

thermo 10000
variable dt_dump equal 10
dump vels interface custom ${dt_dump} ${filename}.vels.dat id type vx vy vz
dump_modify vels format "%d %d %.8g %.8g %.8g"
dump_modify vels sort id

dump pos interface custom 1000 ${filename}.pos.dat id type x y z
dump_modify pos format "%d %d %.8g %.8g %.8g"
dump_modify pos sort id
run ${steps_simu}

reset_timestep 0
dump name1 all custom 1 dump_final.${filename} id type x y z vx vy vz
run 1
undump name1
undump vels
undump pos

write_restart ${filename}.end.restart
print "all done"


After this simulation, one will get the velocity file *.vels.dat. This file is usually several GB. To make the velocity file more compact, a C++ code named compactify_vels.cpp was written (by Kimmo) to speed up the reading process by MATLAB code in the next steps. After the compilation of the code, we can easily use the code by the command: 

To compile and run executable:

-- g++ compactify_vels.cpp
-- #This will give a file called 'a.out'
-- mv a.out compactify
-- chmod 777 compactify
-- ./compactify *.vels.dat *.vels.compact.dat

This will convert the *vels.dat file, originally produced by lammps, to *.vels.compact.dat, who's volume is much smaller than the original velocity file. 


Step 2: calculate the force constant file
An example of calculating the force constant matrix using lammps is as follows:

atom_style      atomic
units           metal
dimension       3
boundary        p p p
processors      1 1 *

# ATOM DEFINITION
neighbor 2 bin
neigh_modify delay 10
neighbor        2.0 nsq
neigh_modify delay 0 every 1 check yes

variable file string SiGe0.5_${CS}
variable filetowrite string ${file}.Fij.dat

atom_modify map hash
read_data position_8-${file}
#read_restart ${file}.equil.restart

pair_style sw
pair_coeff * * /data/isilon/xiong/lammps/potential/SiGe.sw  Si Ge
timestep 0.0008 # Used in ?

# The definition for the interface, extent and location
variable dmid equal 3.0
variable zmid equal (zhi+zlo)/2.0
variable zmidlo equal ${zmid}-${dmid}
variable zmidhi equal ${zmid}+${dmid}

region left block INF INF INF INF ${zmidlo} ${zmid} units box
region right block INF INF INF INF ${zmid} ${zmidhi} units box

group interface_left region left
group interface_right region right

# Belongs to left interface
print 'The interface is at ${zmidlo}, ${zmid}, ${zmidhi}'

group interface union interface_left interface_right

compute fxfyfz interface property/atom fx fy fz

compute fxs interface property/atom fx
compute fys interface property/atom fy
compute fzs interface property/atom fz


# run 0
fix NVE all nve

variable N equal "count(all)"
variable NL equal "count(interface_left)"
variable NR equal "count(interface_right)"

# Initialize groups
group thisi id 1

variable hstep equal 0.01 # Amount of displacement
variable hstepm2 equal -2*v_hstep

shell rm ${filetowrite}

dump helpdump interface custom 1 ${filetowrite} id c_fxs c_fys c_fzs
dump_modify helpdump sort id
dump_modify helpdump append yes
# WRITE THE INTERFACE PARTICLES IDs and TYPEs TO ${filetowrite}

print "NL ${NL}" append ${filetowrite}
print "NR ${NR}" append ${filetowrite}

label loop1
variable i1 loop $N
        variable zi equal z[${i1}]
        variable boolleft equal (${zi}<=${zmid})&&(${zi}>=${zmidlo})
        variable boolright equal (${zi}>${zmid})&&(${zi}<=${zmidhi})
        if "${boolleft}" then &
                "print '${i1} 1' append ${filetowrite}"
        if "${boolright}" then &
                "print '${i1} 2' append ${filetowrite}"
        next i1
jump SELF loop1

print "HSTEP ${hstep}" append ${filetowrite}
thermo_modify flush yes

variable counter equal 0

label loop_i

variable i loop $N
         variable zi equal z[${i}]
         variable boolleft equal (${zi}<=${zmid})&&(${zi}>=${zmidlo})
         variable boolright equal (${zi}>${zmid})&&(${zi}<=${zmidhi})
         print '$i ${boolleft} ${boolright}'
         if "!${boolleft}" then &
            "next i" &
            "jump SELF loop_i" &
            "jump SELF final_break"

         group thisi delete
         group thisi id $i

         # X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION

         displace_atoms thisi move ${hstep} 0 0
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move ${hstepm2} 0 0
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move ${hstep} 0 0

         # Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION

         displace_atoms thisi move 0 ${hstep} 0
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move 0 ${hstepm2} 0
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move 0 ${hstep} 0

         # Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION
         displace_atoms thisi move 0 0 ${hstep}
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move 0 0 ${hstepm2}
         variable counter equal ${counter}+1
         reset_timestep ${counter}
         print "counter=${counter}"
         run 0 # Update the forces in the compute

         displace_atoms thisi move 0 0 ${hstep}

next i
jump SELF loop_i
label final_break
print "all done"


This will produce the force constants in the file *.Fij.dat. Note that in both velocity and force constant calculation file, we need to define the interface region. The size of the the interface region is defined by the variable dmid. The value of dmid should be exactly the same in both files. 

With the obtained velocity and force constant files, we can calculate the transmission functions. The transmission function needs to be averaged by several datasets. Usually, we can perform a very long simulation, and we can divide the long velocity trajectory into several pieces. With each piece, we can calculate one transmission function, and the average can be taken over those transmissions. For random alloy systems, we recommend to perform several systems with different starting configurations. For each configuration we can get several transmission functions and the final average can be averaged over the transmissions of different configurations.

A MATLAB code (Tr_MD.m) is used to calculate the transmission function. Several parameters such as CS, dT, kval and tn should be modified depending on the case. The corresponding explanations of those parameters can be found in the matlab code. Note that, to use the Tr_MD.m code, an additional Gaussian function code gaussian_my.m should be put in the same directory. 
